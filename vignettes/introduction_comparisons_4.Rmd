---
title:"Significance Testing Of Differences Between Predictions IV: Contrasts And Comparisons For Zero-Inflation Models"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Significance Testing Of Differences Between Predictions IV: Contrasts And Comparisons For Zero-Inflation Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r set-options, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  fig.width = 7,
  fig.height = 3.5,
  message = FALSE, warning = FALSE
)
options(width = 800)
arrow_color <- "#FF00cc"

pkgs <- c(
  "ggplot2",
  "marginaleffects",
  "emmeans",
  "htmltools",
  "glmmTMB"
)

if (!all(vapply(pkgs, requireNamespace, quietly = TRUE, FUN.VALUE = logical(1L)))) {
  knitr::opts_chunk$set(eval = FALSE)
}
```

```{r echo=FALSE, message=FALSE}
library(htmltools)
callout_tip <- function(header = NULL, ...) {
  div(
    class = "callout-tip",
    tags$h1(
      tags$img(src = "../man/figures/summary.png", width = "20", height = "17", style = "vertical-align:middle"), # nolint
      header
    ),
    ...
  )
}
includeCSS("../man/figures/callout.css")
```

This vignette is the last in a 4-part series:

1. [**Significance Testing of Differences Between Predictions I: Contrasts and Pairwise Comparisons**](https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_1.html)

2. [**Significance Testing of Differences Between Predictions II: Comparisons of Slopes, Floodlight and Spotlight Analysis (Johnson-Neyman Intervals)**](https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_2.html)

3. [**Significance Testing of Differences Between Predictions III: Contrasts and Comparisons for Generalized Linear Models**](https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_3.html)

4. **Significance Testing of Differences Between Predictions IV: Contrasts and Comparisons for Zero-Inflation Models**


# Contrasts and comparisons for Zero-Inflation Models

Lastly, we show an example for models with zero-inflation component.

## What is a zero-inflated model?

A zero-inflated model is a statistical approach used when dealing with count data that has an excessive number of zero values. Imagine counting something that can be zero, like the number of customers a store gets in a day, and it happens that there are a lot more zeros in the data than a typical count model (e.g., Poisson regression) would ecpect. That's where we need zero-inflated regression models. These models consider two ways zeros can happen:

- True Zeros: These are days the store is naturally closed, or maybe there's just no demand for the product.

- Counting Zeros: These are days the store is open but just happens to get no customers. Maybe it's bad luck, or a random fluctuation.

The model treats these differently. It uses one part (the _zero-inflation_ component, a logistic regression) to predict the probability of a true zero, based on things that make the store less likely to be open at all. Then it uses another part (the _conditional_, or _count_ component, a count regression) to predict the number of customers on days the store is actually open, considering other factors like weather or discounts.

Consequently, such regression models usually have two parts in their formula, or (depending on the package) separate formulas for the count and the zero-inflation components. Adjusted predictions can be calculated for both parts, and contrasts or comparisons can be calculated for both parts, too.

## How to choose predictors for zero-inflation models?

The two model parts do not necessarily need to use the same predictors. Therefore, it is not always straightforward to find predictors that can be used in the zero-inflation model. Think about why you have excess zeros in your data. Are they true zeros (inherently no counts) or due to limitations (measurement limitations, biological process, ...)? Choose variables that explain why some data points have zero counts even when conditions might allow for some count. For instance, if modeling customer complaints, store location in a remote area might predict zero complaints due to fewer customers.

```{r echo=FALSE}
callout_tip(
  "Summary of most important points:",
  tags$ul(
    tags$li("Predictions (returned by ", tags$code("predict_response()"), ") are usually on the response scale. This is also true for other regression models than linear regression. E.g., predictions for logistic regression are presented as probailities, and for Poisson regression, the average count of event is returned."), # nolint
    tags$li(tags$code("test_predictions()"), " also returns contrasts and comparisons on the response scale by default. This is usually the most intuitive scale for people to understand. E.g., for a logistic regression model, contrasts are presented as difference between two probabilities (in percentage points)."), # nolint
    tags$li("It is possible to return contrasts or comparisons on other scales, too - but mostly, this is probably not necessary.") # nolint
  )
)
```

# Zero-inflation models using the *glmmTMB* package

In the following example, we use the `Salamanders` dataset from the `glmmTMB` package.We fit a zero-inflated Poisson regression model to the data, with `mined` as the predictor variable.

Adjusted predictions using `predict_response()` can be made for the different model components:

- The **conditional, or count component**, which predicts the average count of salamanders. This is the default and uses `type = "fixed"`. This would return the predicted mean from the count component only, which is the conditional mean (average counts) of the reponse only for "counting zeros". It does not take into account the probability of "true zeros".

- The **full model**, which predicts the average count of the response, including the zero-inflation component. This would return the expected value of the response for an average observation, which *can* be a "true zero" or a "count zero". Use `type = "zero_inflation"` to calculate adjusted predictions that also take the zero-inflation component into account. For the above example, use this option if you want to predict the average number of customers per week, including days the store is closed.

- The **zero-inflation probabilities**, which predicts the probabilities whether an observation is a "true zero" or not. Use `type = "zi_prob"` for this. It only related to the zero-inflation component of the model.

We will start with the conditional mean, using `margin = "empirical"`, as we want to average across random effects (see [introduction on random effects](https://strengejacke.github.io/ggeffects/articles/introduction_randomeffects.html) for details).

```{r}
library(ggeffects)
library(glmmTMB)

data(Salamanders)
m <- glmmTMB(count ~ mined + (1 | site),
  ziformula = ~mined,
  family = poisson(),
  data = Salamanders
)

# predicting the conditional mean
predict_response(m, "mined", margin = "empirical")
```

## Contrasts and comparisons for the conditional model

For the conditional (or count) part of zero-inflation models. Contrasts or comparisons 

```{r message=TRUE}
p <- predict_response(m, "x1")
test_predictions(p)
```

```{r echo=FALSE}
ht8 <- test_predictions(p)
```

The difference between the predicted probability of `x1 = 1` (`r sprintf("%.1f%%", 100 * p$predicted[1])`) and `x1 = 2` (`r sprintf("%.1f%%", 100 * p$predicted[2])`) is roughly `r sprintf("%.1f%%", 100 * ht8$Contrast[1])` points. This difference is not statistically significant (p = `r round(ht8$p.value[1], 3)`).

The `scale` argument in `test_predictions()` can be used to return contrasts or comparisons on a differen scale. For example, to transform contrasts to _odds ratios_, we can use `scale = "exp"`.

```{r message=TRUE}
test_predictions(p, scale = "exp")
```

Contrasts or comparisons can also be represented on the link-scale, in this case as _log-odds_. To do so, use `scale = "link"`.

```{r message=TRUE}
test_predictions(p, scale = "link")
```

## Contrasts and comparisons for numerical focal terms

For numeric focal variables, where the slopes (linear trends) are estimated, transformed scales (like `scale = "exp"`) are not supported. However, `scale = "link"` can be used to return untransformed contrasts or comparisons on the link-scale.

```{r message=TRUE}
test_predictions(m, "x2", scale = "link")
```

Be aware whether and which back-transformation to use, as it affects the resulting p-values. A detailed overview of transformations can be found [in this vignette](https://marginaleffects.com/vignettes/comparisons.html).

## Contrasts and comparisons for different `margin` options

Like in `predict_response()`, the `margin` argument can be used in `test_predictions()` to define how to marginalize over the *non-focal* predictors, i.e. those variables that are *not* specified in `terms`. This can be important depending on the type of regression models in order to calculate accurate comparisons or contrasts, since these refer to the _difference_ between predicted values.

For linear models, these differences are usually the same, regardless of the `margin` option. However, for non-Gaussian models, differences between predicted values may differ for the different `margin` options.

```{r message=TRUE}
# predictions, using mean/mode for non-focal predictors
p1 <- predict_response(m, "x1")
# predictions, averaged across non-focal predictors
p2 <- predict_response(m, "x1", margin = "empirical")

p1

p2

# differences between predicted values
diff(p1$predicted)
diff(p2$predicted)
```

Consequently, `test_predictions()` *either* requires specifying the `margin` argument when a model and `terms` argument are provided, or the related `ggeffects` object returned by `predict_response()`.

```{r message=TRUE}
# contrast refers to predictions, using mean/mode for non-focal predictors
test_predictions(m, "x1")

# contrast refers to predictions, averaged across non-focal predictors
test_predictions(m, "x1", margin = "empirical")

# or
test_predictions(p2)
```
