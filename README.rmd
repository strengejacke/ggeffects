---
output: 
  github_document:
    toc: false
    fig_width: 7
    fig_height: 5
vignette: >
  %\VignetteIndexEntry{README}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: paper/paper.bib
editor_options: 
  chunk_output_type: console
---

```{r, echo = FALSE, warning=FALSE, message=FALSE}
options(digits = 2)

knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "man/figures/",
  fig.width = 7,
  fig.height = 5,
  comment = "#>",
  dev = "png"
)

.supported_models <- unique(sort(c(
  "wblm", "wbm", "phylolm", "phyloglm", "mblogit", "mclogit", "logitr", "averaging",
  "orm", "mlogit", "glimML", "cgam", "ols", "mixor", "glmx", "lrm", "lmrob", "feglm",
  "glmrob", "glmRob", "brglm", "bigglm", "biglm", "speedglm", "speedlm", "svyglm.nb",
  "svyglm", "stanreg", "brmsfit", "bayesx", "gamlss", "bamlss", "gam", "tobit",
  "survreg", "Gam", "MCMCglmm", "glmerMod", "glmmTMB", "nlmerMod", "lmerMod",
  "merModLmerTest", "rlmerMod", "lme", "logistf", "ivreg", "fixest", "gls", "geeglm",
  "clmm", "clm", "clm2", "polr", "rq", "rqss", "gee", "plm", "negbin", "vgam", "vglm",
  "lm_robust", "lmrob", "lmRob", "betareg", "truncreg", "coxph", "brmultinom",
  "multinom", "bracl", "Zelig-relogit", "zerotrunc", "zeroinfl", "hurdle", "MixMod",
  "glm", "lm", "tidymodels", "betabin", "bglmer", "blmer", "cgamm", "gamm", "gamm4",
  "glm.nb", "polr", "rlm", "rqs", "glmer.nb", "glmmPQL", "nestedLogit", "sdmTMB",
  "flic", "flac"
)))
```

# ggeffects - Estimated Marginal Means and Adjusted Predictions from Regression Models<img src="man/figures/logo.png" align="right" />

[![DOI](http://joss.theoj.org/papers/10.21105/joss.00772/status.svg)](https://doi.org/10.21105/joss.00772) [![Documentation](https://img.shields.io/badge/documentation-ggeffects-orange.svg?colorB=E91E63)](https://strengejacke.github.io/ggeffects/) [![downloads](http://cranlogs.r-pkg.org/badges/ggeffects)](https://cranlogs.r-pkg.org/) [![total](http://cranlogs.r-pkg.org/badges/grand-total/ggeffects)](https://cranlogs.r-pkg.org/)

Lüdecke D (2018). _ggeffects: Tidy Data Frames of Marginal Effects from Regression Models._ Journal of Open Source Software, 3(26), 772. doi: [10.21105/joss.00772](https://doi.org/10.21105/joss.00772)

## Why do we need (marginal/conditional) effects or (adjusted) predicted values?

Results of regression models are typically presented as tables that are easy to understand. For more complex models that include interaction or transformed terms (like quadratic or spline terms), tables with raw regression coefficients are less helpful and difficult to interpret. In such cases, _marginal effects_ or _adjusted predictions_ are far easier to understand. In particular, the visualization of such effects or predictions allows to intuitively get the idea of how predictors and outcome are associated, even for complex models. 

## Aim of this package

**ggeffects** is a light-weight package that aims at easily calculating marginal effects and adjusted predictions (or: _estimated marginal means_) at the mean or at representative values of covariates ([see definitions here](https://stats.stackexchange.com/tags/marginal-effect/info)) from statistical models, i.e. **predictions generated by a model when one holds the non-focal variables constant and varies the focal variable(s)**. Furthermore, it is possible to compute contrasts or pairwise comparisons, to test predictions and differences in predictions for statistical significance.

This is achieved by three core ideas that describe the philosophy of the function design: 

  1) Functions are type-safe and always return a data frame with the same, consistent structure;
  
  2) there is a simple, unique approach to calculate marginal effects/adjusted predictions and estimated marginal means for many different models;
  
  3) the package supports "labelled data" [@daniel_ludecke_2018_1249216], which allows human readable annotations for graphical outputs.
  
This means, users do not need to care about any expensive steps after modeling to visualize the results. The returned as data frame is ready to use with the **ggplot2**-package, however, there is also a `plot()`-method to easily create publication-ready figures.

Adjusted predictions or estimated marginal means are always calculated on the *response* scale, which is the easiest and most intuitive scale to interpret the results.

It is easy to start, you just need one function: `predict_response()`, and two arguments: the model and the "focal terms", i.e. the predictors that you are mainly interested in. Examples are shown below.

## So, when do I need the *ggeffects* package?

You should use *ggeffects*...

- ... when you want to understand how predictors and outcome are related, no matter whether you have simple or complex models, interaction or transformed terms. See how to start [in this vignette](https://strengejacke.github.io/ggeffects/articles/ggeffects.html). The syntax for the *ggeffects* functions is super easy and consistent across the different type of models and complexity.

- ... when you want to perform pairwise comparisons, in order to see whether there are statistically significant differences in the association of, for instance, different groups or categories of your predictors and your outcome. There are several vignettes describing this in detail, starting [with this vignette](https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_1.html).

- ... when you need impressive figures instead of long, confusing tables to describe your results. There are several examples in the [documentation](https://strengejacke.github.io/ggeffects/), for example [this vignette](https://strengejacke.github.io/ggeffects/articles/introduction_plotmethod.html).

- ... and even when you want to check, whether your model appropriately describes your data. See [this vignette](https://strengejacke.github.io/ggeffects/articles/introduction_partial_residuals.html) to learn more about how to use *ggeffects* for model diagnostics.

## Installation

[![CRAN](https://www.r-pkg.org/badges/version/ggeffects)](https://cran.r-project.org/package=ggeffects) [![parameters status badge](https://strengejacke.r-universe.dev/badges/ggeffects)](https://strengejacke.r-universe.dev)

Type | Source | Command
---|---|---
Release | CRAN | `install.packages("ggeffects")`
Development | r - universe | `install.packages("ggeffects", repos = "https://strengejacke.r-universe.dev")`
Development | GitHub | `remotes::install_github("strengejacke/ggeffects")`

Or you can run [`ggeffects::install_latest()`](https://strengejacke.github.io/ggeffects/reference/install_latest.html) to install the latest development version from r-universe.

## Definition of "marginal effects"

There is no common language across fields regarding a unique meaning of "marginal effects". Thus, the wording throughout this package may vary. Maybe "adjusted predictions" comes closest to what **ggeffects** actually does. To avoid confusion about what is actually calculated and returned by the different marginalization options in `predict_response()` (or the different package's functions `ggpredict()`, `ggemmeans()` and `ggeffect()`), it is recommended to read [this vignette](https://strengejacke.github.io/ggeffects/articles/introduction_marginal_effects.html) about the different terminology and its meanings.

## marginal effects: marginalizing over non-focal predictors

`predict_response()` is a wrapper around `ggpredict()`, `ggeffect()`, `ggemmeans()` and `ggaverage()`. Depending on the value of the `marginalize` argument, `predict_response()` calls one of those functions, sometimes with different arguments. It's important to note that:

1. Predictions are always returned on the *response scale*, no matter which model is used. This is the most intuitive scale to interpret your results (the predicted values).

2. The response is predicted for the values or levels of your *focal terms*, i.e. you specify the predictors you are mainly interested in, using the `terms` argument. The predicted values are calculated for these values, while all other predictors are marginalized over.

The `marginalize` argument in `predict_response()` indicates how to marginalize over the *non-focal* predictors, i.e. those variables that are *not* specified in `terms`. Possible values are:

- `"mean_reference"`: calls `ggpredict()`, i.e. non-focal predictors are set to their mean (numeric variables) or reference level (factors, or "lowest" value in case of character vectors).
- `"mean_mode"`: calls `ggpredict(typical = c(numeric = "mean", factor = "mode"))`, i.e. non-focal predictors are set to their mean (numeric variables) or mode (factors, or "most common" value in case of character vectors).
- `"marginalmeans"`: calls `ggemmeans()`, i.e. non-focal predictors are#'   set to their mean (numeric variables) or marginalized over the levels or "values" for factors and character vectors. Marginalizing over the factor levels of non-focal terms computes a kind of "weighted average" for the values at which these terms are hold constant.
- `"empirical"`: calls `ggaverage()`, i.e. non-focal predictors are marginalized over the observations in your sample. Technically, `ggaverage()` calculates predicted values for each observation in the data multiple times, each time fixing all values or levels of the focal terms to and then takes the average of these predicted values (aggregated/grouped by the focal terms).

For all the above options, the *differences* between predicted values are identical - if your main interest is to investigate "group differences" or "inequalities", it doesn't matter much, which way you choose. However, if you are specificall interested in the predicted values of your response, you should consider the differences between the options. Predictions based on `"mean_reference"` and `"mean_mode"` represent a rather "theoretical" view, which does not necessarily exactly reflects your sample. `"marginalmeans"` comes closer to the sample, because it takes all possible values and levels of your non-focal predictors into account. `"empirical"` is the most "realistic" approach, because it is based on the actual observations in your sample.

## Documentation and Support

Please visit [https://strengejacke.github.io/ggeffects/](https://strengejacke.github.io/ggeffects/) for documentation and vignettes. For questions about the functionality, you may either contact me via email or also file an issue.

## ggeffects supports many different models and is easy to use

Marginal effects and adjusted predictions can be calculated for many different models. Currently supported model-objects are: `r datawizard::text_concatenate(.supported_models, enclose = "'")`.

Support for models varies by function, i.e. although `ggpredict()`, `ggemmeans()`, `ggeffect()` and `ggaverage()` support most models, some models are only supported exclusively by one of the three functions. Thus, not all `marginalize` options in `predict_response()` will support all models. Other models not listed here might work as well, but are currently not tested.

Interaction terms, splines and polynomial terms are also supported. There is a generic `plot()`-method to plot the results using **ggplot2**.

## Examples

The returned data frames always have the same, consistent structure and column names, so it's easy to create ggplot-plots without the need to re-write the function call. `x` and `predicted` are the values for the x- and y-axis. `conf.low` and `conf.high` could be used as `ymin` and `ymax` aesthetics for ribbons to add confidence bands to the plot. `group` can be used as grouping-aesthetics, or for faceting.

`ggpredict()` requires at least one, but not more than four terms specified in the `terms`-argument. Predicted values of the response, along the values of the first term are calculated, optionally grouped by the other terms specified in `terms`.

### Adjusted predictions for one focal predictor

```{r message=FALSE, warning=FALSE}
library(ggeffects)
library(splines)
data(efc)
fit <- lm(barthtot ~ c12hour + bs(neg_c_7) * c161sex + e42dep, data = efc)

predict_response(fit, terms = "c12hour")
```

A possible call to ggplot could look like this:

```{r message=FALSE, warning=FALSE}
library(ggplot2)
mydf <- predict_response(fit, terms = "c12hour")
ggplot(mydf, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.1)
```

However, there is also a `plot()`-method. This method uses convenient defaults, to easily create the most suitable plot for the marginal effects.

```{r message=FALSE, warning=FALSE}
mydf <- predict_response(fit, terms = "c12hour")
plot(mydf)
```

### Adjusted predictions for several focal predictors

With three variables, predictions can be grouped and faceted.

```{r message=FALSE, warning=FALSE}
predict_response(fit, terms = c("neg_c_7", "c161sex", "e42dep"))

mydf <- predict_response(fit, terms = c("neg_c_7", "c161sex", "e42dep"))
ggplot(mydf, aes(x = x, y = predicted, colour = group)) +
  geom_line() +
  facet_wrap(~facet)
```

`plot()` works for this case, as well:

```{r message=FALSE, warning=FALSE}
plot(mydf)
```

### Contrasts and pairwise comparisons

Next, an example of an interaction term. We want to know whether the two slopes are significantly different from each other.

```{r message=FALSE, warning=FALSE}
fit <- lm(neg_c_7 ~ c12hour + barthtot * c161sex + e42dep, data = efc)
result <- predict_response(fit, c("barthtot", "c161sex"))
plot(result)
```

This can be achieved by `test_predictions()`.

```{r message=FALSE, warning=FALSE}
test_predictions(result)
```

We can conclude that slopes (or "linear trends") of `barthtot` for the different groups of `c161sex` are not statistically significantly different from each other.

More features are explained in detail in the [package-vignettes](https://strengejacke.github.io/ggeffects/).

## Citation

In case you want / have to cite my package, please use `citation('ggeffects')` for citation information:

Lüdecke D (2018). _ggeffects: Tidy Data Frames of Marginal Effects from Regression Models._ Journal of Open Source Software, 3(26), 772. doi: [10.21105/joss.00772](https://doi.org/10.21105/joss.00772)

## References
