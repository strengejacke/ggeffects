% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_predictions.R
\name{get_predictions}
\alias{get_predictions}
\alias{get_predictions.default}
\title{S3-class definition for the ggeffects package}
\usage{
get_predictions(model, ...)

\method{get_predictions}{default}(
  model,
  data_grid = NULL,
  terms = NULL,
  ci_level,
  type = NULL,
  typical = NULL,
  vcov = NULL,
  vcov_args = NULL,
  condition = NULL,
  interval = "confidence",
  bias_correction = FALSE,
  model_info = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{model, terms, ci_level, type, typical, vcov, vcov_args, condition, interval, bias_correction, verbose}{Arguments
from the call to \code{predict_response()} that are passed down to \code{get_predictions()}.}

\item{...}{Further arguments, passed to \code{predict()} or other methods used
in \code{get_predictions()}.}

\item{data_grid}{A data frame containing the data grid (or reference grid)
with all relevant values of predictors for which the adjusted predictions
should be made. Typically the data frame that is passed to the \code{newdata}
argument in \code{predict()}. A data grid can be created with functions like
\code{\link[=data_grid]{data_grid()}} or \code{\link[insight:get_datagrid]{insight::get_datagrid()}}.}

\item{model_info}{An object returned by \code{\link[insight:model_info]{insight::model_info()}}.}
}
\value{
A data frame that contains
\itemize{
\item the data grid
\item the columns \code{predicted}, \code{conf.low}, and \code{conf.high}
\item optionally, the attribute \code{"std.error"} with the standard errors.
}

Note that predictions and confidence intervals should already be transformed
to the \emph{response} scale (e.g., by using \code{insight::link_inverse()}). The
\emph{standard errors} are always on the link scale (not transformed).

If values are not available (for example, confidence intervals), set their
value to \code{NA}.
}
\description{
\code{get_predictions()} is the core function to return adjusted
predictions for a model, when calling \code{ggpredict()} or \code{predict_response()}
with \code{margin = "mean_reference"} (the default option for \code{margin}).
Basically, the input contains the model object and a data grid that is
typically used for the \code{newdata} argument of the \code{predict()} method.
\code{get_predictions()} can be used as S3-method for own classes, to add support
for new models in \strong{ggeffects} and is only relevant for package developers.

There are no S3-class definitions for \code{ggemmeans()} or \code{ggaverage()}, because
these functions simply call methods from the \strong{emmeans} or \strong{marginaleffects}
packages. Hence, methods should be written for those packages, too, if a
model-object should work with \code{ggemmeans()} or \code{ggaverage()}.
}
\details{
The above mentioned arguments are all passed from \code{predict_response()} to
\code{get_predictions()}, no matter if they are required to calculate predictions
or not. Thus, it is not necessary to accept or process all of those
arguments, but they can be used to modulate certain settings when calculating
predictions. It is important that the function returns a data frame with a
specific structure, namely the data grid and the columns \code{predicted},
\code{conf.low}, and \code{conf.high}. Predictions and intervals should be on the
response scale.

A simple example for an own class-implementation for Gaussian-alike models
could look like this:

\if{html}{\out{<div class="sourceCode">}}\preformatted{get_predictions.own_class <- function(model, data_grid, ci_level = 0.95, ...) \{
  predictions <- predict(
    model,
    newdata = data_grid,
    type = "response",
    se.fit = !is.na(ci_level),
    ...
  )

  # do we have standard errors?
  if (is.na(ci_level)) \{
    # copy predictions
    data_grid$predicted <- as.vector(predictions)
  \} else \{
    # copy predictions
    data_grid$predicted <- predictions$fit

    # calculate CI
    data_grid$conf.low <- predictions$fit - qnorm(0.975) * predictions$se.fit
    data_grid$conf.high <- predictions$fit + qnorm(0.975) * predictions$se.fit

    # optional: copy standard errors
    attr(data_grid, "std.error") <- predictions$se.fit
  \}

  data_grid
\}
}\if{html}{\out{</div>}}

A simple example for an own class-implementation for non-Gaussian-alike models
could look like this (note the use of the link-inverse function \code{linv()}):

\if{html}{\out{<div class="sourceCode">}}\preformatted{get_predictions.own_class <- function(model, data_grid, ci_level = 0.95, ...) \{
  # get link-inverse-function
  linv <- insight::link_inverse(model)
  if (is.null(linv)) \{
    linv <- function(x) x
  \}

  predictions <- predict(
    model,
    newdata = data_grid,
    type = "link", # for non-Gaussian, return on link-scale
    se.fit = !is.na(ci_level),
    ...
  )

  # do we have standard errors?
  if (is.na(ci_level)) \{
    # copy predictions
    data_grid$predicted <- linv(as.vector(predictions))
  \} else \{
    # copy predictions
    data_grid$predicted <- linv(predictions$fit) # use link-inverse to back-transform

    # calculate CI
    data_grid$conf.low <- linv(predictions$fit - qnorm(0.975) * predictions$se.fit)
    data_grid$conf.high <- linv(predictions$fit + qnorm(0.975) * predictions$se.fit)

    # optional: copy standard errors
    attr(data_grid, "std.error") <- predictions$se.fit
  \}

  data_grid
\}
}\if{html}{\out{</div>}}
}
